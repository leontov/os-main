# Formula Evolution Handbook / Руководство по эволюции формул / 公式进化手册

**Copyright (c) 2025 Кочуров Владислав Евгеньевич**

---

## 1. Concept / Концепция / 概念


- Каждый ген — это последовательность из 32 десятичных цифр, задающая тип операции
  и параметры (`k`, `b`, вспомогательное значение).
- Пул содержит до 24 активных генов, которые мутируют и соревнуются.
- Fitness вычисляется по средней абсолютной ошибке с штрафом за «тяжёлые» цифры,
  поощряя компактные и интерпретируемые решения.

- Формула представляется парой коэффициентов `(a, b)` и фитнесом.
- Пул содержит до 16 активных формул, которые мутируют и соревнуются.
- Fitness измеряет соответствие задачам; более успешные формулы доминируют.


---

## 2. Data Structures / Структуры данных / 数据结构

```c
typedef struct {
    uint8_t digits[32];
    size_t length;
} KolibriGene;

typedef struct {
    KolibriGene gene;

    int a;
    int b;

    double fitness;
} KolibriFormula;

typedef struct {
    KolibriFormula formulas[24];
    size_t count;
    KolibriRng rng;
    int inputs[64];
    int targets[64];
    size_t examples;

    KolibriFormula formulas[16];
    size_t count;
    KolibriRng rng;

} KolibriFormulaPool;
```

---

## 3. Lifecycle / Жизненный цикл / 生命周期

1. **Инициализация:** `kf_pool_init(pool, seed)` создаёт случайные гены длиной 32 цифры.
2. **Накопление данных:** `kf_pool_add_example(pool, x, y)` добавляет пары из REPL `:teach`.
3. **Эволюция:** `kf_pool_tick(pool, generations)`
   - Декодирует цифры в операции (`линейная`, `инверсная`, `остаточная`, `квадратичная`).
   - Вычисляет fitness = `1/(1 + Σ|f(x_i) - y_i|) - penalty`.
   - Сохраняет верхнюю треть генов, остальные перезаписывает потомками кроссовера.
4. **Применение:** `kf_formula_apply(formula, x, &out)` возвращает значение и проверяет переполнения.
5. **Объяснение:** `kf_formula_describe` печатает тип операции, коэффициенты и текущий фитнес.

## 4. Fitness Function / Функция приспособленности / 适应度函数


- Используется обратная сумма абсолютных ошибок с штрафом за сложность:
  \[
  fitness = \max\left(0, \frac{1}{1 + \sum |f(x_i) - y_i|} - 0.001 \cdot \sum digits\right)
  \]
- Чем компактнее ген (меньше ненулевых цифр), тем ниже штраф и выше итоговый фитнес.

- Используется обратная средняя абсолютная ошибка:
  \[
  fitness = 1.0 / (1.0 + \frac{1}{n} \sum |f(x_i) - y_i|)
  \]
- Значение в диапазоне `(0, 1]`. Чем ближе к 1, тем лучше.


---

## 5. Mutation Strategy / Стратегия мутаций / 变异策略


- Гены делятся пополам: первая часть берётся у родителя A, вторая — у родителя B.
- Мутация выбирает случайную позицию и заменяет цифру другой (`0–9`).
- Длина гена фиксирована (32 цифры), что упрощает сетевую миграцию и журналирование.

- С вероятностью 0.5 изменяется коэффициент `a` на `-1, 0 или 1`.
- Коэффициент `b` мутирует аналогичным образом.
- Новые значения ограничиваются диапазоном `[-128, 128]` для предотвращения переполнений.


---

## 6. Integration with Genome / Интеграция с геномом / 与基因组集成

- Лучшие гены сериализуются как строки цифр и записываются в Kolibri Chain.
- События фиксируют тип операции, фитнес и исходную последовательность для воспроизводимости.

- Каждая формула, достигшая порога fitness > 0.75, логируется в Kolibri Chain.
- Событие записывается как `event_type="FORMULA_EVOLVED"`, payload содержит `a`, `b`, fitness.


---

## 7. Manual Feedback / Ручная обратная связь / 人工反馈

- Команда `:teach` добавляет пары вход/выход и запускает сокращённый цикл эволюции.
- `:tick`/`:evolve` задают количество поколений, `:why` печатает описание гена и фитнес.
- Все действия фиксируются в цифровом геноме для пост-фактум анализа.

- Команды REPL `:good` и `:bad` масштабируют fitness лучшей формулы, ускоряя обучение.
- `:why` возвращает параметры текущей формулы и источник данных.


---

## 8. Extending the Model / Расширение модели / 模型扩展

- Для добавления новых операторов используйте дополнительные значения в первой цифре гена и обновите `kf_formula_describe`.
- Property-тесты должны проверять, что мутация возвращает цифры `0–9`, а fitness остаётся конечным при любых примерах.

- Добавление новых операторов (например, квадратичные члены) требует изменения `KolibriFormula` и сериализации.
- Property-тесты должны проверять, что мутации не выходят за допустимый диапазон и fitness остаётся конечным.

