# Kolibri OS Overview / Обзор Kolibri OS / Kolibri OS 概览

**Copyright (c) 2025 Кочуров Владислав Евгеньевич**

---

## 1. Mission / Миссия / 使命

Обеспечить автономный запуск ядра Kolibri на минимальном оборудовании без зависимости от полноценных ОС.

---

## 2. Boot Sequence / Последовательность загрузки / 启动流程

1. BIOS передаёт управление загрузчику `kolibri.asm` (512 байт, записываемому в MBR).
2. Загрузчик инициализирует видеорежим 80x25, выводит приветствие и находит секции ядра.
3. Загружает бинарник Kolibri Core в память, передаёт управление точке входа `kolibri_start`.
4. Ядро инициализирует RNG, формульный пул, геном и сетевой стек (при наличии драйверов).

---

## 3. Memory Map / Карта памяти / 内存布局

| Address | Description |
|---------|-------------|
| 0x0000:7C00 | Бут-сектор `kolibri.asm` |
| 0x0000:8000 | Таблица параметров (seed, node id) |
| 0x0010:0000 | Загружаемый бинарник `kolibri.bin` |
| 0x0020:0000 | Рабочая область ядра / стеки |

---

## 4. Configuration Block / Конфигурационный блок / 配置块

```
struct KolibriBootConfig {
    uint32_t seed;
    uint32_t node_id;
    uint16_t listen_port;
    uint16_t reserved;
};
```

Загрузчик заполняет структуру и передаёт адрес в регистре `SI` ядру.

---

## 5. Console Interface / Консольный интерфейс / 控制台接口

- Поддерживает команды REPL, аналогичные десктопной версии.
- Использует BIOS interrupt 0x10 для ввода/вывода.
- Буфер команд ограничен 128 символами; истории нет.

### 5.1 Kolibri AI Autopilot / Автоматический сценарий ядра / 自动化启动流程

1. Ядро читает `KolibriBootConfig`, инициализирует RNG и пул формул (`kf_pool_init`).
2. Загружает RAM‑диск с `genome.dat` через `kg_open` поверх `ramdisk_init`, восстанавливая счётчики и реплей блоков; по завершении сессии журнал сбрасывается обратно через `ramdisk_commit`.
3. Проводит короткую фазу обучения: вызывает `kf_pool_add_example` для встроенных примеров, затем `kf_pool_tick(pool, 32)`.
4. Вычисляет предварительный ответ `kf_formula_apply(best, probe, &out)` для нескольких значений и печатает сводку на консоль и на последовательный порт.
5. При активном сетевом интерфейсе включает драйвер SLIP/UDP (`kn_slip_udp_init`) и отправляет приветствие `HELLO:<node>` по последовательному каналу.
6. Переходит в REPL: принимает команды пользователя и периодически вызывает `kn_listener_poll`, сохраняя импортированные гены в пул.

---

## 6. Build & Emulation / Сборка и эмуляция / 构建与仿真

1. Запустите `scripts/package_release.sh` — он выполнит тесты, соберёт ядро (`scripts/build_iso.sh --kernel-only`), запакует загрузчик `boot/kolibri.asm` и положит образ `build/kolibri.img`.
2. Для ручной отладки ядра достаточно `scripts/build_iso.sh --kernel-only`, затем `nasm -f bin boot/kolibri.asm -o build/kolibri_boot.bin` и `dd` для объединения загрузчика и `build/kolibri.bin`.
3. Эмулируйте систему: `qemu-system-x86_64 -drive format=raw,file=build/kolibri.img,if=ide`.

---

## 7. Telemetry & Serial Output / Телеметрия через последовательный порт / 串口遥测

| Префикс | Назначение | Пример |
|---------|------------|--------|
| `[STATE]` | Важные этапы загрузки и автопилота (`boot.enter`, `rng.init`, `autopilot.done`). | `[STATE] seed: 0x01312FBB` |
| `[BEST ]` | Описание лучшей формулы из пула после эволюции. | `[BEST ] y=03*x+07` |
| `[GENE ]` | Сырые цифры гена в одной строке. | `[GENE ] 1 2 3 4 5` |

Каждый кадр SLIP/UDP начинается с `HELLO:<node>` и кодируется по стандарту SLIP (`0xC0` как граница, `0xDB 0xDC` и `0xDB 0xDD` для экранирования). Полезная нагрузка упакована в IPv4/UDP с портом из `KolibriBootConfig`.

## 8. Roadmap / Дорожная карта / 路线图

- [x] Автоматическая упаковка бинарника и загрузчика в `scripts/package_release.sh`.
- [x] Сетевой драйвер с поддержкой SLIP/UDP для обмена формулами прямо из Kolibri OS.
- [x] Минимальный файловый слой для хранения `genome.dat` на RAM-диске.
- [ ] Интеграция с визуальным монитором через последовательный порт.
