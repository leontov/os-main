# Текущее состояние Kolibri OS

Проект уже включает работающую модель симулятора KolibriSim с эволюцией формул, журналом событий и длительными прогонами, которые хранятся только в памяти и выгружаются через вспомогательные утилиты.【F:core/kolibri_sim.py†L1-L145】 Frontend собран как чат-клиент, который инициализирует WebAssembly-модуль `kolibri.wasm`, выделяет память через экспорт `malloc` и выполняет KolibriScript внутри браузера посредством моста `KolibriWasmBridge`.【F:frontend/src/core/kolibri-bridge.ts†L1-L134】【F:frontend/src/App.tsx†L1-L99】 UI реагирует на состояние инициализации моста и показывает ошибки ядра напрямую в чат.【F:frontend/src/App.tsx†L14-L86】 Сборка на C уровне обеспечивает библиотеки и тесты, но пока ориентирована только на native-артефакты без WebAssembly-целей.【F:CMakeLists.txt†L1-L68】 Документация описывает загрузочную последовательность и будущие задачи, однако указывает на отсутствующий загрузчик и автоматизацию упаковки.【F:docs/kolibri_os.md†L13-L79】 В Python-тулчейне сохранён лишь заглушечный `requirements.txt`, что подчёркивает нехватку формализованного управления зависимостями.【F:requirements.txt†L1-L4】

## Следующие шаги до релиза
1. **Собрать Kolibri ядро в WebAssembly и включить его в фронтенд-пайплайн.** В текущем `CMakeLists.txt` объявлены лишь native-таргеты; требуется добавить конфигурацию для Emscripten, экспортировать функции `kolibri_bridge_*` и автоматизировать публикацию `kolibri.wasm` для CI/CD.【F:CMakeLists.txt†L1-L68】【F:frontend/src/core/kolibri-bridge.ts†L1-L134】
2. **Закончить загрузчик `kolibri.asm` и автоматизировать упаковку образа.** Документация описывает шаги, но сам бут-сектор и скрипты упаковки отсутствуют, поэтому необходимо реализовать ассемблерный код и обвязку сборки.【F:docs/kolibri_os.md†L13-L70】
3. **Добавить файловый слой и хранение генома в ОС.** Roadmap фиксирует задачу по RAM-диску для `genome.dat`; реализация обеспечит сохранность эволюционных данных между сеансами.【F:docs/kolibri_os.md†L74-L79】
4. **Внедрить сетевой драйвер SLIP/UDP в ядре.** Для обмена формулами в реальном времени нужно реализовать описанный в дорожной карте сетевой стек.【F:docs/kolibri_os.md†L74-L79】
5. **Интегрировать визуальный монитор через последовательный порт.** Это позволит отслеживать состояние узла Kolibri во время загрузки и работы, как запланировано в roadmap.【F:docs/kolibri_os.md†L74-L79】
6. **Перевести журнал KolibriSim на устойчивое хранение.** Сейчас журнал и сдвиг оффсета живут в памяти; стоит добавить сброс на диск и ротацию для долговременных прогонов.【F:core/kolibri_sim.py†L94-L145】
7. **Расширить CLI длительных прогонов аналитикой.** Скрипт `scripts/soak.py` сохраняет только последнюю порцию метрик; полезно добавить агрегацию по сессиям и экспорт в форматы для дашбордов.【F:scripts/soak.py†L1-L61】
8. **Формализовать Python-зависимости и окружения.** Заглушечный `requirements.txt` нужно заменить реальным списком пакетов (pytest, ruff и т. д.) и описанием среды для воспроизводимых CI.【F:requirements.txt†L1-L4】
9. **Усилить тестовое покрытие KolibriSim.** Текущий набор проверяет базовые сценарии; следует добавить стресс-тесты на синхронизацию, ошибки HMAC и восстановление состояния для повышения уверенности перед релизом.【F:tests/test_kolibri_sim.py†L1-L169】
10. **Защитить мост от деградации производительности и регрессий.** Следует добавить smoke-тесты wasm-инстанцирования, мониторинг размера `kolibri.wasm` и профилирование ответа UI, чтобы раннее выявлять ошибки линковки и переполнения памяти.【F:frontend/src/core/kolibri-bridge.ts†L23-L123】【F:frontend/src/App.tsx†L14-L86】
